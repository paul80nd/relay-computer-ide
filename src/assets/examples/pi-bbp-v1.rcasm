; *****************************************************************************************
;  Calculation of Pi to 20 decimal places
;
;  Uses the Bailey-Borwein-Plouffe (BBP) formula to compute Pi digit by digit in base 16.
;  Expected duration: 6m42s at default clock speed. Version v0.4
;
;              ◯◯
;            ┌───╮  ┏         ╭                                          ╮  ┓
;   ┳━┳  ━━   ╲     ┃    1    │    4          2          1          1    │  ┃
;   ┃ ┃  ━━   ╱     ┃  ─────  │  ─────  ━━  ─────  ━━  ─────  ━━  ─────  │  ┃
;            ╰───╯  ┃  16 ^k  │  8k +1      8k +4      8k +5      8k +6  │  ┃
;             k=0   ┗         ╰                                          ╯  ┛
;
;  Result is correct to 17 hex places (by calculating to 19hp over 16 iterations of BBP)
;  which when converted to decimal provides 20dp result. Target of program is to produce:
;
;    32 43 f6 a8 88 5a 30 8d 31     (pi)       [9 byte Big Endian Q4.68]
;
;  After each BBP iteration the value of Pi will build up in ps_s as follows with accuracy
;  to n hex digits following n iterations. Remaining digits are partial results.
;
;    39 31 8d 30 5a 88 a8 f6 43 32  (psum)     [10 byte Little Endian Q4.76]
;
;  In each BBP iteration the fractions are calculated first (as reciprocals) to required
;  precision - i.e. no more than 1/16^k right shift would throw away:
;  (example values from 7th iteration at k=6)
;
;    01 4e 5e 0a 72 f0 53           (fra = 4/49 >> 24)      [7 byte BE]
;    00 9d 89 d8 9d 89 d8           (frb = 2/52 >> 24)      [7 byte BE]
;    00 4d 48 73 ec ad e3           (frc = 1/53 >> 24)      [7 byte BE]
;    00 4b da 12 f6 84 bd           (frd = 1/54 >> 24)      [7 byte BE]
;
;  These values are then converted to little endian (LE) in preparation for long addition
;  and pb, pc and pd are two's complemented to effect subtraction through addition:
;
;    53 f0 72 0a 5e 4e 01           (fra = fra)             [7 byte LE]
;    28 76 62 27 76 62 ff           (frb = -frb)            [7 byte LE]
;    1d 52 13 8c b7 b2 ff           (frc = -frc)            [7 byte LE]
;    43 7b 09 ed 25 b4 ff           (frd = -frd)            [7 byte LE]
;
;  Long addition is then performed for frb, frc and frd accumulating into fra:
;
;    db 33 f2 aa b1 17 00           (fra = fra-frb-frc-frd) [7 byte LE]
;
;  Finally the result of fra is added to psum completing the BBP iteration.
;
; *****************************************************************************************

        jmp start       ; jump to start of program (keep zero page free for major variables)

; ***************************************************************
;  Major variables of Pi calculation ...
;
;  We keep these early (and aligned) in the zero page of memory
;  to ease viewing in the computer and emulator. Aligns & orgs
;  can be removed to shorten the assembled output.
; ***************************************************************

dv:     !byte 121       ; divisor (representing 8k+1 at start of each iteration)

        org 0x07
pi:     !fill 9,0xaa    ; final result of Pi [9 byte Big Endian Q4.68] (area marked with 0xaa for visibility)
psum:   !fill 10,0      ; intermediate sum of Pi [10 byte Little Endian Q4.76]

        !align 16       ; expected final psum value (used purely for sight check - can be deleted without impact)
psexp:  !byte 0x39, 0x31, 0x8d, 0x30, 0x5a, 0x88, 0xa8, 0xf6, 0x43, 0x32

        !align 16
fra:    !fill 10,0      ; first BBP fraction and iteration accumulator [max 10 byte LE]
        !align 16
frb:    !fill 10,0      ; second BBP fraction
        !align 16
frc:    !fill 10,0      ; third BBP fraction
        !align 16
frd:    !fill 10,0      ; fourth BBP fraction

; ***************************************************************
;  Start of main program ... core Pi calculation follows ...
; ***************************************************************

        ; cheat start at k = 14 result (used whilst building the program up)
cheat:  !byte 0xf8, 0x30, 0x8d, 0x30, 0x5a, 0x88, 0xa8, 0xf6, 0x43, 0x32

start:  ldi m,psum§cheat   ; Copy cheat k = 14 into psum
        ldi b,10
        jsr copy

        ; Calculate the four reciprocals

        ldi m,fra§dv      ; fra = 1/dv (1 / 8k+1)
        ldi b,2
        jsr long_rcp

        ldi m,dv          ; dv += 3
        ldr c
        ldi b,3
        add
        str a

        ldi m,frb§dv      ; frb = 1/dv (1 / 8k+4)
        ldi b,2
        jsr long_rcp

        ldi m,dv          ; dv++
        ldr b
        inc
        str a

        ldi m,frc§dv      ; frc = 1/dv (1 / 8k+5)
        ldi b,2
        jsr long_rcp

        ldi m,dv          ; dv++
        ldr b
        inc
        str a

        ldi m,frd§dv      ; frd = 1/dv (1 / 8k+6)
        ldi b,2
        jsr long_rcp

hlt
;k = 15 -- 32m47s
;    ···············0876 (4/121) >> 60
;  - ···············0421 (2/124) >> 60
;  - ···············020c (1/125) >> 60
;  - ···············0208 (1/126) >> 60
;  = ···············0041
;
;  + 32 43 f6 a8 88 5a 30 8d 30 f8
;  = 3243f6a8885a308d3139


        ; We now have Pi to 19hp LE in psum!
        ; Last step is to copy and truncate to 17hp then convert to BE

        ldi m,pi§psum+1 ; Copy 9 bytes of psum to pi ignoring first LE byte
        ldi b,9
        jsr copy

        ldi m,pi        ; Convert pi LE to BE
        ldi b,9
        jsr reverse

        hlt

; ***************************************************************
;  End of main program ... subroutines follow ...
;  Most have separate examples available with demo & comments
; ***************************************************************

; ***************************************************************
;  Purpose:   Copy block of memory within zero page
;
;  Inputs:    M1 = Location of target block start (low byte)
;             M2 = Location of source block start (low byte)
;              B = Number of bytes to copy
;
;  Clobbered: ABCD and M
; ***************************************************************
copy: {
        not             ; set up loop counter in D
        mov b,a
        inc d
        mov b,m1        ; capture target in M1
        clr m1

  loop: ldr a           ; copy byte (B is tgt, M2 is src)
        mov c,m2
        mov m2,b
        str a

        mov b,d         ; bump loop - exit when 0
        inc d
        beq done

        mov b,c         ; bump src (C is src, M2 is tgt)
        inc
        mov b,m2        ; swap src and tgt
        mov m2,a
        inc             ; bump tgt
        mov b,a
        jmp loop

  done: rts
}

; ***************************************************************
;  Purpose:   Byte-by-byte endian conversion (reverse bytes)
;
;  Inputs:    M = Location of value start
;             B = Length of value in bytes
;
;  Notes:     Value will be converted in-place and must be
;             within single memory page.
;
;  Clobbered: ABCD and M
; ***************************************************************
reverse: {

        ; Set up first and last byte pointers (A and D)
        mov a,m2        ; A is just M2
        mov c,m2        ; D is M2+C-1
        add d
        ldi b,-1
        mov c,d
        add d

        ; Registers are in the following state
        ;  A = low address of first byte
        ;  D = low address of last byte
        ;  M = address of first byte
        ; XY = return address

        ; On entry to the loop M is pointing at 1st of pair.
        ; M2 = A and D is low address of 2nd of pair.
        ; We now just need to swap them via B and C registers.
  loop: ldr b
        mov m2,d
        ldr c
        str b
        mov m2,a
        str c

        ; We now need to increment A and decrement D
        mov b,a
        inc a
        ldi b,-1
        mov c,d
        add d

        ; We now take A from D however this needs a bit of
        ; juggling to keep in registers
        mov c,d         ; take A and D to ALU
        mov b,a
        not d           ; negate B via D
        mov b,d
        inc d
        mov b,d
        add d           ; subtract
        mov d,c         ; restore D

        ; If result is less than or equal to 0 we're done
        ; Even swaps set sign flag and odds zero flag hence ble.
        ble rtn

        ; Otherwise we're going for another loop so set M2 = A
        mov m2,a
        jmp loop

        ; Jump to return address held in XY register
   rtn: rts
}

; ***************************************************************
;  Purpose:   Byte-by-byte long reciprocal: (M) = 1 / M1
;
;  Inputs:    M1 = Location to store result (zero page)
;             M2 = Location of divisor value (zero page - max 127)
;              B = Number of bytes to calculate result to
;
;  Notes:     Resulting reciprocal is little-endian and consists of
;             only the fractional part (integral is assummed 0).
;             Operates on the zero page so M1 + B must be in ZP.
;
;  Clobbered: ABCD, M and XY
; ***************************************************************
long_rcp: {

        ; Terms
        ;   A = remainder (register A - ongoing)
        ;   Q = quotient (register D - current byte)
        ;   V = divisor (register X)

        ; Because we'll be using XY as a general register we write the
        ; return address directly in to the jump instruction at rtn.
        ; That also means a bit of juggling to prepare our registers.
        mov c,x         ; Capture return address in CD
        mov d,y
        mov xy,m        ; Preserve M in XY
        ldi m,rtn+1     ; Set return address from CD
        str c
        ldi m,rtn+2
        str d
        mov c,x         ; Preserve X in C (result location)
        mov m2,y        ; Load divisor in to X
        clr m1
        ldr a
        mov x,a
        mov y,c         ; Set end address in Y (C)
        add d           ; Set result start location (C+B)
        mov m2,d

        ; We now prepare for the first loop iteration. Result is built up byte-by-byte
        ; in the A loop and within that bit-by-bit in an unrolled B loop.
        mov b,x         ; Negate -V in X
        not d
        mov b,d
        inc d
        mov x,d
        ldi a,1         ; A=1
        clr m1          ; M1=0 (zero page)

        ; Registers are now in the following state
        ;   A = 1 = remainder with 1 'shifted' in (A)
        ;   D = Initial quotient of 0 (Q)
        ;  M1 = 0 (zero page)
        ;  M2 = result location (zero page)
        ;  X = divisor value (-V)
        ;  Y = address after result (zero page)
        ; Now in state of 1 'shifted' into A and flags set

        ; Because we start at location (C+B) we're one cell further than intended
        ; Therefore we move the M2 decrement to the start of the loop rather than the end
a_loop: mov c,m2        ; decrement M2
        ldi b,-1
        add d
        mov m2,d

        ; Set up for the next byte of the overall result with reset Q.
        ldi b,0         ; Set up next quotient (Q)
        mov d,b

b_loop: ; Original B loop is unrolled here (duplicated 8 times) to
        ; build reciprocal bit-by-bit at expense of duplicated code

        ; Shift remainder and perform trial subtraction of V
        ; If negative then C=0 and restore else C=1 and keep
    _7: mov b,a         ; A << 1 (via x2)
        mov c,a
        add a
        mov b,a         ; A = A + -V
        mov c,x
        add
        bmi _7neg       ; Restore and set C to 0 if negative
        ldi b,1         ; Otherwise keep result and set C to 1
        mov c,b
        jmp _7set

        ; If A - V was negative we restore the remainder and clear C
 _7neg: mov a,b
        clr c

        ; We can now shift Q left and apply the 1 or 0 in register C
 _7set: mov b,d         ; (Q << 1) + C
        rol d
        mov b,d
        add d

        ; Following are now just the above repeated another times
        ; thereby 'unrolling the loop'

    _6: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _6neg
        ldi b,1
        mov c,b
        jmp _6set
 _6neg: mov a,b
        clr c
 _6set: mov b,d
        rol d
        mov b,d
        add d

    _5: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _5neg
        ldi b,1
        mov c,b
        jmp _5set
 _5neg: mov a,b
        clr c
 _5set: mov b,d
        rol d
        mov b,d
        add d

    _4: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _4neg
        ldi b,1
        mov c,b
        jmp _4set
 _4neg: mov a,b
        clr c
 _4set: mov b,d
        rol d
        mov b,d
        add d

    _3: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _3neg
        ldi b,1
        mov c,b
        jmp _3set
 _3neg: mov a,b
        clr c
 _3set: mov b,d
        rol d
        mov b,d
        add d

    _2: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _2neg
        ldi b,1
        mov c,b
        jmp _2set
 _2neg: mov a,b
        clr c
 _2set: mov b,d
        rol d
        mov b,d
        add d

    _1: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _1neg
        ldi b,1
        mov c,b
        jmp _1set
 _1neg: mov a,b
        clr c
 _1set: mov b,d
        rol d
        mov b,d
        add d

    _0: mov b,a
        mov c,a
        add a
        mov b,a
        mov c,x
        add
        bmi _0neg
        ldi b,1
        mov c,b
        jmp _0set
 _0neg: mov a,b
        clr c
 _0set: mov b,d
        rol d
        mov b,d
        add d

 b_end: str d           ; D now contains our complete byte so we'll store it in memory

        mov b,m2        ; Check if on last byte (M2=Y)
        mov c,y
        eor d
rtn:    beq *           ; Done if so
        jmp a_loop      ; otherwise loop.
}
