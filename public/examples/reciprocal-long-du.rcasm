; *****************************************************
;  Example of byte-by-byte long reciprocal using the
;  proposed hardware divider unit
;
;    01 / 05            (ra = 1/5 to 4 bytes)
;  = 33 33 33 33
;
;    01 / 0e            (rb = 1/14 to 6 bytes)
;  = 12 49 24 92 49 24
;
;    01 / 2d            (rc = 1/45 to 8 bytes)
;  = 05 b0 5b 05 b0 5b 05 b0
;
;    01 / 7d            (rd = 1/125 to 10 bytes)
;  = 02 0c 49 ba 5e 35 3f 7c ed 91
;
;  Expected duration:   5m52s at default clock speed
;      (around 40m saving on software only approach)
; *****************************************************

; Perform each reciprocal in turn by calling function
; Note we use the special '§' operator to pack two 8-bit
; values into the 16-bit M register in the form M1§M2

        ldi m,5§ra         ; sa = 1/5 (4 bytes)
        ldi b,4
        jsr long_du_rcp

        ldi m,14§rb        ; rb = 1/14 (6 bytes)
        ldi b,6
        jsr long_du_rcp

        ldi m,45§rc        ; rc = 1/45 (8 bytes)
        ldi b,8
        jsr long_du_rcp

        ldi m,125§rd       ; rd = 1/125 (10 bytes)
        ldi b,10
        jsr long_du_rcp

        hlt

; Reserve values in memory (bytes are little-endian ordered)
; Values are aligned and initialised to 1s-4s for da-dd
; respectively to ease visability in memory viewer

        !align 16
ra:     !fill 4, 0x11
        !fill 2, 0
rd:     !fill 10, 0x44
rb:     !fill 6, 0x22
        !fill 2,0
rc:     !fill 8, 0x33

; *****************************************************
;  Byte-by-byte Long Reciprocal: (M) = 1 / M1
;
;    M1: Divisor value (max 127)
;    M2: Location to store result (zero page)
;     B: Number of bytes to calculate result to
;
;  Resulting reciprocal is big-endian and consists of
;  only the fractional part (integral is assummed 0).
;  Operates on the zero page so M2 + B must be in ZP.
;
;  Mutates ABCD and M
;  REQUIRES HARDWARE DIVIDER UNIT
; *****************************************************
long_du_rcp: {

        ; Calculate end address D = M2 + B
        mov c,m2
        add d

        ; Prepare the divider unit by performing the initial
        ; division of 1 / V. This will produce a quotient of zero
        ; with a remainder of 1 stored in the divider unit's
        ; remainder carry-in register (DR).
        ldi b,1         ; Initial dividend of 1
        mov c,m1
        div

 loop:  ; Loop building reciprocal byte-by-byte

        clr m1          ; Set up M to point to 00M2

        ; Peform continued remainder division
        ; This uses bit-by-bit restoring divider hardware
        ; for 0 / V but with the previous remainder carried in.
        ; Effectively it'l produce the next fractional byte
        clr b
        dvr

        ; A now contains our next byte so we'll store it in memory.
        str a

        ; We can now bump M2 to point at the next location in memory
        ; and check if we've completed the reciprocal by checking the
        ; end address in D.
        mov b,m2        ; bump M2
        inc
        mov m2,a
        mov m1,c        ; preserve divisor in M1
        mov c,d         ; check if gone past last byte
        mov b,a
        cmp
        mov c,m1        ; restore divisor
        bne loop        ; next loop if not done

        rts             ; Otherwise return
}
